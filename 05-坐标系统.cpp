总结：
    1.使用多个坐标系统的原因是，在特定的坐标系统中操作或运算更加方便
    2.坐标变换是通过矩阵变换实现的：模型、观察、投影

    3.顶点着色器的输出要求所有的顶点都在裁剪空间内 通过变换矩阵：Vclip=Mprojection⋅Mview⋅Mmodel⋅Vlocal，变换后赋值到顶点着色器中的gl_Position变量中
    4.获得裁剪坐标后，OpenGL通过透视除法映射到标准化设备坐标
    5.再通过glViewPort将标准化设备坐标映射到屏幕坐标

    总之：顶点着色器->|| 局部 <-(Mmodel)-> 世界 <-(Mview)-> 观察 <-(Mprojection)-> 裁剪 ||-> <-(透视除法+视口变换)-> 屏幕
      ①顶点着色器之前进行 局部->世界->观察->裁剪，然后输出裁剪坐标
      ②通过透视除法再映射到标准化设备坐标
      ③通过glViewPort(视口变换)映射到屏幕坐标

概述：
    1.局部空间
    {
        //相对于物体局部原点的坐标
    }

    2.世界空间
    {
        //相对世界原点摆放很多物体

        //从局部空间变换到世界空间通过 模型 矩阵变换
    }

    3.观察空间
    {
        //将世界空间坐标转换为用户视野前方的坐标

        //从世界空间变换到观察空间通过 观察 矩阵变换
    }

    4.裁剪空间
    {
        //处理至-1.0 - 1.0范围内

        //从观察空间变换到裁剪空间通过 投影 矩阵变换

        //由投影矩阵创建的观察箱称之为 平截头体

        //投影：将 特定范围 的坐标转换到 标准设备坐标系 的过程

        //透视除法：被变换到裁剪空间的坐标都会在-w到w的范围之间，将xyz分量除以w分量

        //投影矩阵的分类：
        (1)正射投影矩阵

        (2)透视投影矩阵
            透视：近大远小的效果
            修改了每个顶点的w分量，使产生透视效果
    }

    5.屏幕空间
    {

    }

    6.Z缓冲
    {
        //解决OpenGL绘制覆盖的问题
        
        //深度测试(OpenGL自动完成)：OpenGL通过对比想要输出的片段中存储的深度值和Z缓冲进行对比，如果当前的片段在其他片段之后，则丢弃，否则覆盖。
        glEnable(GL_DEPTH_TEST);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

